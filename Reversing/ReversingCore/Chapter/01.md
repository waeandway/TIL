## 1부 : 기초 리버싱

### **01 리버싱 스토리**
- **리버싱(=리버스 엔지니어링, Reverse Engineering)** <br>
소프트웨어의 구조, 기능, 동작 등을 분석해 그 원리를 이해하며 단점을 보완하고 새로운 아이디어를 추가하는 일련의 작업

- **리버싱 방법**
> **정적 분석** <span style="color:red">파일을 실행하지 않고 분석</span>하는 방법, 또는 디스어셈블러를 통해 내부코드 및 구조를 확인하는 과정 <br>
> **동적 분석** <span style="color:red">파일을 직접 실행해</span>(디버깅) 코드흐름과 메모리 상태 등을 자세히 살펴보는 방법

- **소스 코드 vs 헥사 코드 vs 어셈블리 코드**
> **소스 코드** (Windows기준) 소스 코드 빌드업 시 .exe 실행파일 생성 <br>
> **헥사 코드** 디스어셈블러에서 .exe 실행파일(binary)을 16진수 hex 형식으로 변환 <br>
> **어셈블리 코드** 헥사코드를 디스어셈블 과정을 거쳐 어셈블리 코드로 변환

- **패치와 크랙**
> **패치** 프로그램의 파일 혹은 실행 중인 프로세스 메모리의 내용을 변경하는 작업 → 프로그램의 취약점 수정과 기능 개선<br>
> **크랙** 패치와 같은 개념이지만 특별히 그 의도가 비합법적이고 비도덕적인 경우 → 주로 저작권을 침해
<br>

### **02 Hello World! 리버싱**
```
//-- hello-world.cpp --//

#include <Windows.h>
#include <stdio.h>
char* str;
int main() {
  int delay = 1000;
  Sleep(delay);  // 1000ms(1초)를 대기합니다.
  str = (char*)"Hello, world!\n";
  printf(str);
  return 0;
}
```
- **디버거와 어셈블리 언어** 디버거에 탑재된 디스어셈블러는 모듈은 실행파일(binary)을 어셈블리 언어로 번역해서 보여줌

- **디버깅 목표** 어셈블리 언어로 변환된 main()함수 찾기 **[실습]()** <br>

><span style="color:gray">※ ***OP code** Operation code, 명령어 코드* <br>
>※ ***Stub code** 컴파일러가 프로그램을 만들 때 집어넣는 코드, 디버깅 시 사용자코드와 구분할 줄 알아야 한다.* 
</span>

| 디버거 환경 | 내용 |
|:----------:|:----------|
| **EP(Entry Point)** | Windows 실행파일(EXE, DLL, SYS 등)의 코드 시작점, 프로그램이 실행될 때 CPU에 의해 가장 먼저 실행되는 코드 시작위치 |
| **Address** |  프로세스의 가상 메모리(Virtual Address:VA) 내의 주소 |
| **Instruction** | IA32(또는 x86) CPU 명령어 |
| **Disassembled code** | OP code를 보기 쉽게 어셈블리로 변환한 코드 |
| **comment** | 디버거에서 추가한 주석 <span style="color:gray">*주석의 빨간글씨부분 ~ 코드에서 호출되는 API*</span> |

<br>

| 디버거 명령어(Code영역에서 동작) | 내용 |
|:----------:|:----------|
| **Restart [Ctrl+F2]** | 디버깅 다시시작, 디버깅을 당하는 프로세스를 종료하고 재실행 |
| **Step Into [F7]** | 하나의 OP code 실행 (<span style="color:red">CALL 명령을 만나면, 그 함수 코드내부로 들어감</span>) |
| **Step Over [F8]** | 하나의 OP code 실행 (<span style="color:red">CALL 명령을 만나면, 코드내부로 들어가지 않고 그냥 함수자체를 실행</span>) |
| **Execute till Return [Ctrl+F9]** | 함수코드 내에서 RETN 명령어까지 실행(함수 탈출 목적) |
| Go to [Ctrl+G] | 원하는 주소로 이동 (코드/메모리를 확인할 때 사용, 실행되는 것은 아님) |
| Execute till Cursor [F4] | cursor 위치까지 실행 (디버깅하고 싶은 주소까지 바로 갈 수 있음) |
| Comment [;], Label[:] | Comment - 주석 추가, Label - 라벨 추가  |
| Set/Reset BP [F2] | BP 설정/해제 <span style="color:gray"> *BreakPoint*</span> |
| Run [F9] | 실행 (BP가 걸려있으면 그곳에서 실행이 정지됨) |
| Show the current EIP [*] | 현재 EIP 위치를 보여줌 <span style="color:gray"> *Extended Instruction Pointer*</span> |
| Show the previous Cursor [-] | 직전 커서 위치를 다시 보여줌 |
| Preview CALL/JMP address [Enter] | 커서가 CALL/JMP 등의 명령어에 위치해 있다면, 해당 주소를 따라가서 보여줌 (실행되는 것이 아님, 간단히 함수 내용을 확인할 때 유용) |








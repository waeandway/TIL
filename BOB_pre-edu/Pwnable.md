# 시스템 보안
## 목차
1. [운영체제 이론](#1-운영체제-이론-⬆️목차)
2. [해킹의 개요](#2-해킹의-개요-⬆️목차)

---
## 1. 운영체제 이론 [⬆️](#목차)

### 운영체제의 역할과 목적
>**운영체제 (Operating System, OS)** <br>
>응용프로그램~HW의 인터페이스이자, <span style="color:red">시스템자원(기억장치, 프로세서, 입출력장치, 정보, 네트워크 등)</span>을 효율적으로 관리할 수 있음

>**운영체제의 목적** <br>
>1. 편리성 <br>
>ex) GUI(Graphic User Interface) → 생산성 기대, MMI(Man-Machine Interface) <br>
>2. 효율성 <br>
>처리 능력 향상&응답시간 단축 : <span style="color:red">단위 시간 내에 최대한 많은 양의 일을 처리</span> → 멀티 프로그래밍&스레딩 <br>신뢰도 향상(HW(FW)/SW) : 시스템이 정확하게 작동되는 정도 <br>사용가능도(가동률)

### 운영체제의 기능과 구조
>**기능**
>1. 자원 관리
>- 프로세스 관리 : 프로세스 스케줄링을 통해 실행 가능한 프로세스 추적 관리
>- 메모리 관리
>- 주기억장치 관리 : 주기억장치 접근, 주소 변환, 기억 보호, 버퍼 기억  ex) RAM ROM
>- 보조기억장치 관리 : SSD, HD, USB 등의 기억장치에 대한 접근 관리, 제어
>- 파일관리: 파일에 대한 조작, 저장방식, 접근방법에 대한 관리
>>- 주변장치 관리(입출력 관리) <br>
   >>① 장치 구동기(Device Driver) <br>
   >>② 데이터의 입출력 방식 : 프로그램에 의한 입출력, 인터럽트, DMA(Direct Memory Access) <br>
   >>>③ 버퍼링과 스풀링 <br>
   >>>**버퍼링(Buffering)** <span style="color:red">~ MEMORY</span> : I/O와 보조기억장치의 처리속도가 CPU의 처리속도보다 느린 문제를 보완하는 방법 중 하나, CPU가 하나의 연산을 시작하면 I/O가 다음에 필요한 레코드를 미리 읽어 주기억장치에 저장함으로써 CPU의 대기시간 절감.
   <br>**스풀링(Spooling)** <span style="color:red">~ DISK</span> : 버퍼링과 같은 개념이며, 스풀링은 디스크를 매우 큰 버퍼처럼 사용. ex) 프린터에 RAM이 없는 경우 

>2. 시스템 관리
<br> 시스템 보호(사용자 권한 부여), 네트워크, Command Interpreter

>**구조**
<img src="img/OsFrame.png">

>**커널(Kernel)**
>- HW로부터 프로그램들을 격리시키고, HW와 직접적으로 상호작용함으로써 프로그램들에게 일관된 서비스를 제공.
>-  핵심기능은 <span style="color:red">프로세스와 파일의 관리</span>이며, 그밖에 I/O 관리, 메모리 관리, 시스템 호출 인터페이스 등을 수행한다.
>- <span style="color:red">Interupt 수행</span> ~ 멀티 태스킹 (동시 수행같아 보이지만, 실제로는 Interup를 통한 단일 수행이다.) 

### 운영체제의 기술발전 흐름
>**단순모니터** <br>
컴퓨터 오퍼레이터가 할 일을 자동으로 수행

>**일괄처리 시스템(Batch Processing System)** <br>
여러 개의 작업을 단일 작업으로 묶어 일괄처리 하는 시스템 
<br>보조기억장치의 속도가 느려 처리 시간이 많이 걸림 → 모니터링, 버퍼링, 스풀링 도입

>**다중프로그래밍 시스템** <br>
I/O와 CPU의 속도 차이에 따른 비효율 문제 개선 <br>
주기억장치 내에 2개 이상의 프로그램을 적재해 그 중 하나가 실행될 경우, 실행 중 I/O 등의 조작으로 CPU가 쉬는 시간이 생기면 OS가 다른 프로그램을 실행.

>**시분할 처리시스템(Time-Sharing System, TSS)** <br>
프로세스의 사용시간을 분할(Time Slice)해 다중 사용자가 CPU를 순환해 이용

>**분산처리 시스템(Distributed Processing System, DPS)** <br>
하나의 대형 컴퓨터에서 수행하던 기능을 지역적, 기능적으로 분산된 컴퓨터가 분담해 네트워크를 통해 처리 ~ 자원공유, 계산 속도/신뢰도 향상, 통신 기능

>**다중처리 시스템(Multi Processing System)** <br>
여러 개의 작업을 하나의 시스템(다수의 CPU)에서 동시에 처리할 수 있는 시스템 <br>
여러 개의 프로세스가 메모리에 저장돼 자원이 할당될 때마다 다시 실행되면서 처리를 완료할 때까지 메모리에 존재하는 시스템

>**실시간 시스템(Real time System)** <br>
자료가 발생한 지점에서 단말기를 통해 직접 입출력되므로, 사용자의 노력이 절감됨
<br>→ 처리시간 및 비용 단출, 자료가 무작위로 도착하므로 입출력 자료의 일시저장과 대기가 필요 <br>ex) 클라우드 컴퓨팅

### 운영체제의 주요 구성 기술
>**1. 프로세스 관리** <br><br>
**프로세스** <br>
현재 수행 상태에 있는 프로그램으로, 여러 명령어/데이터/카운터/CPU 레지스터/루틴 인자/복귀 주소/저장된 변수 등 데이터 스택 포함 <br><br>
**프로세스의 상태 변화** <br>
생성(*new*) : 새로 만들어졌지만, 운영체제에 의해 실행 가능한 프로세스 집합에 포함되지 않은 상태 <br>
준비(*ready*) : 프로세스가 실행되고 있진 않으나, 즉시 CPU를 사용할 수 있는 대기 상태 <br>
실행(*running*) : 현재 CPU를 차지해 동작중인 상태 <br>
대기(*waiting*) : 어떤 이벤트가 발생하기 전까지는 실행될 수 없는 상태 <br>
보류(*terminated*) : 프로세스가 디스크 등에 보관돼 있는 상태 <br>
교착(*suspend*) : 결코 일어날 수 없는 사건을 기다리는 상태 <br>
종료(*exit*) : OS에 의해 프로세스 집합에서 해제된 상태 <br><br>
**프로세스 제어 블록 (Process Control Block, PCB)** <br>
운영 체제가 프로세스에 대한 중요한 정보를 저장한 저장소 <br>
운영체제는 프로세스의 실행 중단 시, 중단 후 재실행 시 등의 경우에 PCB를 참조 <br><br>
**스레드와 태스크** <br>
스레드(*Tread*) : 스레드는 프로세스를 수행하는 데 필요한 가능한 많은 하위 작업들 중 하나 (프로세스보다 작은 단위로, 프로세스 스케줄링의 단위가 됨) <br>
태스크(*Task*) : 자원 할당의 단위로 프로세스와 같은 개념 ~ Linux (프로세스는 Windows)<br><br>
>**<span style="color:red">프로세스 vs 스레드 vs 태스크**</span> <br><br>
**프로세스 스케줄링** <br>
멀티 프로세스 시스템에서 CPU를 사용하는 프로세스 결정 문제 <br>
~ 스와핑(*Swapping*) : 메모리에서 프로세스를 제거하는 것이 효율적인 경우, 프로세스를 제거했다가 이 프로세스를 다시 호출해 중단되었던 지점부터 실행을 재개 <br>
① 장기 스케줄링 : 어떤 프로세스를 커널에 등록할 것인지를 결정 <br>
② 중기 스케줄링 : 어떤 프로세스에게 메모리를 할당할 것인지를 결정 <br>
③ 단기 스케줄링 : 어떤 프로세스에게 CPU를 할당할 것인지를 결정 <br><br>
**스케줄링 알고리즘** <br>
기준 : CPU 알고리즘, 시스템 처리율, 반환 시간, 대기 시간, 응답 시간 <br>
종류 : FIFO, SJF(*Short Job First*), SRT(*Shortest Remaining Time*), *Priority*, *Round-Robin*, *Multilevel Feedback* 등 <br><br>
**프로세스 간 협조**
>> 생산자와 소비자 문제 (Bounded-Buffer Problem)
>> - 여러 개의 프로세스 동기화 문제
>> - 생산자와 프로세스 소비자 프로세스가 공유하는 버퍼 이요에 따른 동기화
>> - 해결 방법 : 생산자~소비자 협동, <span style="color:red">세마포어(*Semaphore*)</span> 등

>> 임계영역 문제 (Critical Section Problem)
>> - 멀티스레드 또는 멀티프로세스 시 공유하는 변수, 파일, 테이블 등의 동시 변경에 따라 상호 모순이 발생하는 문제
>> - 해결 방법 : 상호배제(*하나의 프로세스가 임계영역에 있으면, 다른 프로세스 출입 금지*), 진행(*Progress, 임계영역에 프로세스가 없을 때 임계영역에 들어가려는 프로세스 순서 경정*), 한계 대기(*Bounded Waiting, 한 번 임계영역에 들어간 프로세스가 다음에 임계영역에 들어갈 때 제한을 둠*)

>**프로세스간 통신** <br>
공유 메모리 방식 : 공유 변수를 통해 정보를 교환하며, OS는 개발자에게 공유 메모리만을 제공 <br>
메시지 시스템 방식 : 프로세스들이 메시지를 교환하도록 허용하는 기법 <br><br>
**교착상태 (Dead lock 또는 Suspend)** <br>
다중 프로그래밍 시스템 아래 서로 다른 프로세스가 일어날 수 없는 사건을 무한정 기다리며 더 이상 진행하지 못하는 상태 (Circular wait) <br>
교착상태 발생 조건 : 상호 배제(*동시에 여러 프로세스 사용불가*), 점유와 대기(*다른 자원을 점유하면서 자신에게 할당된 자원 미해제*), 비중단 조건(*프로세스에 할당된 자원을 끝날 때까지 해제 불가시 = 비선점*), 순환 대기(*Circular wait*) <br>
교착상태 해결 방법 : 예방(*교착상태 발생 조건이 모두 성립되지 않도록 하는 방법*), 회피(*교착상태 발생 조건 중 일부는 성립될 수 있으나, 교착상태를 발생하지 않도록 하는 방법*), 탐지(*교착상태 발생을 허용하고, 발생 시 이를 발견해 원인 규명*), 복구(*교착상태 발견 후, 순환대기를 제거하거나 자원을 중단*) <br>

>**2. 기억장치 관리** <br><br>
**계층적 기억장치 구조** <br>
보조 기억장치 / 주 기억장치 / 캐시 기억장치 (CPU 내 존재) <br>
반입정책(*Fetch*) : ① <span style="color:red">요구반입정책(*Demand Fetch Strategic*)</span> ② <span style="color:red">예상반입정책(*Anticipatory Fetch Strategic*)</span> <br>
배치정책(*Placement*) ~ 메모리 할당 기법 : 최초 적합(*First-fit*), 최적 적합(*Best-fit*), 최악 적합(*Worst-fit*) <br>
교체정책(*Replacement*) <br><br>
**메모리 단편화 문제** <br>
기억장치 관리에서 각 작업에 필요한 기억장치 공간들을 계속적으로 할당 및 회수를 반복할 때, 주 기억장치 중에서 실제로 작업에 사용되지 않고, 유용하게 사용할 수도 없는 공간(단편화)이 발생하는 문제 <br>
~ 내부 단편화(할당된 장소 내), 외부 단편화(작업 분할 영역) <br>
→ 해결방법
>>**압축** : 산재한 기억장소를 한 군데로 모아 최대의 연속된 빈 공간을 확보 <br>
>>**페이징** : 주소공간을 페이지 단위로 나누고, 실제 주소공간은 페이지 크기와 같은 페이지 프레임으로 나누어 사용 <br>
>>**세그먼테이션** : 세그먼트(*프로그램의 논리적 단위가 되는 프로그램의 모듈이나 자료구조*), 세그먼테이션은 가변분할기법으로 프로세스의 주소공간을 동적으로 설정되는 가변크기의 블록들로 변환해 사용하는 것*) 등

>**주기억장치 할당 기법** <br>
① 연속할당 기법 : 프로그램을 주기억장치에 연속을 할당하는 기법 (단일분할, 다중분할 할당) <br>
② 분산할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법 (페이징기법, 세그먼테이션 기법 ~ 둘 다 <span style="color:red">분산할당 기법</span>) <br>
③ 단일분할 할당 기법 : Boundary Register 사용 <br>
④ Overlay <br>
⑤ Swapping : 주기억장치→보조기억장치(*Swap Out*), 보조기억장치→주기억장치(*Swap In*) <br>
⑥ <span style="color:red">다중분할할당기법</span> : 고정분할할당(*고정된 크기로 분할 → 주기억장치의 낭비가 많다, 실행될 프로그램의 크기를 미리 알아야 한다*), 가변분할할당(*고정분할할당의 단편화를 줄이기 위한 방법*)

>**가상기억장치(virtual memory)** <br>
물리적 기억장치의 효율을 위해 논리적으로 확장된 기억장치를 제공하는 기법 <br>
① 요구 페이징 (*Demand paging*) : 실행할 프로그램 일부만 메모리에 적재하는 것, 프로그램의 순차성, 실행 시 일부만 사용 <br>
② 페이징 교체 알고리즘 : FIFO, LRU(*Least Recently Used*), OPT(*OPTimal*), Clock <br>
③ 스래슁 (*Trashing*) : 페이지 교체 시 페이지 부재가 너무 많이 발생해 CPU의 활용도를 떨어뜨리는 현상

>**디스크와 디스크 스케줄링** <br>
디스크 공간 할당 기법 : 연속 할당, 연결 할당, 인덱스 할당 <br>
디스크 스케줄링 기법 : 다수의 사용자가 서로 다른 작업을 처리하기 위해 디스크의 입출력을 요구할 때보다 효율적으로 요청을 처리하기 위한 것 
>> FCFS(First Come First Service) <br>
>> SSTF(Shortest Seek Time First) : 준비상태 큐에 올라운 트랙 중 현재 헤드가 위치한 트랙에서 가장 가까운 요청을 먼저 처리 <br>
>> SCAN : SSTF와 같은 동작을 하지만, 진행 방향 상 가장 가까운 거리에 있는 요청을 먼저 처리 <br>
>> C-SCAN : SCAN과 유사하지만, 헤드가 항상 바깥쪽에서 안쪽으로 이동하면서 가장 가까운 거리에 있는 요청을 서비스함.

>**파일 시스템 관리** <br>
파일과 파일 구조 <br>
>> 파일 : 서로 연관성 있는 데이터의 집단
>> 파일의 구조 : 파일을 구성하는 레코드들이 기억장치에 배치되는 방식
>>>순차 파일 : 물리적 순서에 따라 저장 (자기 테이프, 종이 테이프, 프린트 출력 등) <br>
>>>인덱스된 순차 파일 : 키 값에 따라 논리적인 순서대로 배열 <br>
>>>직접 파일 : 레코드가 직접 액세스 기억장치의 물리적 주소를 통해 직접 액세스

>디렉토리와 디렉토리 구조
>> 디렉토리 : 레코드 각 필드에 대한 배열을 보관하는 파일로, 한 파일 내 레코드의 배치 상황을 서술한 곳. 파일 탐색을 위한 색이인이며, 제어 프로그램을 참도죄면 파일의 명칭, 위치, 날자 등이 저장돼 파일 관리의 중심이 됨
>>> 디렉토리 구조 
>>>>1단계 디레토리 : 모든 파일이 같은 디렉토리, 파일 이름을 구분 필요.
>>>>2단계 디렉토리 : 각 사용자마다 별도의 사용자 파일 디렉토리, 부팅시 마스터 파일 디렉토리(MFD)가 먼저 산책(부팅시 마스터)
 
 >**디렉토리 *

### 운영체제 별 주요 특징
---
## 2. 해킹의 개요 [⬆️](#목차)
 